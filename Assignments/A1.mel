{
    //Reset
    select mPlane;
    string $children[] = `listRelatives -ad -type transform`;
    for($name in $children) {
        select $name;
        doDelete;
    }
    
    //NON ASSIGNMENT PROCS
    proc float[] extractValues(string $stringValues) {
        string $valueList[];
        float $floatValues[];
        $numValues = `tokenize $stringValues $valueList`;
        for($i = 0; $i < $numValues - 2; $i++) {
            $floatValues[$i] = (float) ($valueList[$i+2]);
        }
        
        return $floatValues;
    }
    
    proc float[] normalizeVector(float $vector[]) {
       float $result[3];
       $magnitude = sqrt(($vector[0] * $vector[0]) + ($vector[1] * $vector[1]) + ($vector[2] * $vector[2]));
       $result[0] = $vector[0]/$magnitude;
       $result[1] = $vector[1]/$magnitude;
       $result[2] = $vector[2]/$magnitude;
       return $result;
    }
   
    proc float[] getNormalVector(float $vA[], float $vB[], float $vC[]) {
        float $v1[3], $v2[3];
        $v1[0] = $vA[0] - $vC[0];
        $v1[1] = $vA[1] - $vC[1];
        $v1[2] = $vA[2] - $vC[2];
        
        $v2[0] = $vB[0] - $vC[0];
        $v2[1] = $vB[1] - $vC[1];
        $v2[2] = $vB[2] - $vC[2];
        
        return getCrossProduct($v1, $v2);
    }
      /*
    proc float[] getPlaneEquation(float [] $vA, float [] $vB, float [] $vC) {
        return "Stub";
    }
    proc float[] getPointPlaneDistance(float [] $plane, float [] $point) {
        return "Stub";
    }
    proc float[] getLinePlaneIntersection(float [], float [], float []) {
        return "Stub";
    }
    */
    proc float[] getCorners(string $mesh) {
        float $result[];
        int $facetCount[] = `polyEvaluate -face ($mesh+".f[0]")`;
        int $currentResultIndex = 0;
        if($facetCount[0] == 1) {
            //This is a case where the mesh has only one face, and therefore the corners are just the verts of that face.
            $faceString = `polyInfo -fv ($mesh + ".f[0]")`;
            float $vertexIndeces[] = extractValues($faceString[0]);
            for($i = 0; $i < size($vertexIndeces); $i++) {
                 float $vertex[] = `getAttr ($mesh + ".vt[" + $vertexIndeces[$i] + "]")`;
                 
                 for($f in $vertex) {
                     $result[$currentResultIndex] = $f;
                     $currentResultIndex ++;
                 }
            }
        } else {
            //TODO: handle many different subdivisions, define a corner as any vertex that only has two edges.
            //TODO: handle continuous meshes like a cube or sphere.
        }
        
        return $result;
        
    }
    
    proc float getDotProduct(float $v1[], float $v2[]) {
        float $result;
        
        $result += $v1[0] * $v2[0];
        $result += $v1[1] * $v2[1];
        $result += $v1[2] * $v2[2];

        float $expectedResult = dotProduct($v1,$v2, false);
        if($result != $expectedResult) {
            print("ASSERTION FAILED: Dot product was " + $result + " Instead of " + $expectedResult);
        }
        
        return $result;
    }
    
    
    proc float [] getCrossProduct(float $v1[], float $v2[]) {
        float $resultingVector[4];
        
        $result[0] = ($v1[1] * $v2[2]) - ($v1[2] * $v2[1]);
        $result[1] = ($v1[0] * $v2[2]) - ($v1[2] * $v2[0]);
        $result[2] = ($v1[0] * $v2[1]) - ($v1[1] * $v2[0]);
        
        float $expectedResultingVector[] = crossProduct($v1,$v2, false, false);
        
        if($result[0] != $expectedResultingVector[0]) {
            print("ASSERTION FAILED: Cross product x was " + $result[0] + " Instead of " + $expectedResultingVector[0]);
        }
        
        if($result[1] != $expectedResultingVector[1]) {
            print("ASSERTION FAILED: Cross product y was " + $result[1] + " Instead of " + $expectedResultingVector[1]);
        }
        
        if($result[2] != $expectedResultingVector[2]) {
            print("ASSERTION FAILED: Cross product z was " + $result[2] + " Instead of " + $expectedResultingVector[2]);
        }
        
        
        return $result;
    }
    
    
    select mPlane;
    float $planePosition[3] = `xform -worldSpace -query -translation mPlane`;
    print(getDotProduct({0,1,2},{0,2,3}) + "\n");
    print(getCrossProduct({0,1,2},{0,2,3}));
    float $corners[] = getCorners("mPlane");
    print $corners;
    int $currentCorner = 0;
    for($i = 0; $i < size($corners); $i+=3) {
        string $locator[] = `spaceLocator -p $corners[$i] $corners[$i + 1] $corners[$i + 2] -name ("Corner: "+$currentCorner)`;
        parent -r $locator mPlane ;
        $currentCorner++;
    }
    
    float $normal[3] = getNormalVector({$corners[0],$corners[1],$corners[2]}, {$corners[3],$corners[4],$corners[5]}, {$corners[6],$corners[7],$corners[8]});
    $normal = normalizeVector($normal);
    string $normalWidget = `curve -d 1 -p 0 0 0 -p $normal[0] $normal[1] $normal[2] -k 0 -k 1 `;
    parent -r $normalWidget mPlane;

}